#+title: Advanced Data Structures And Algorithm Analysis
#+author: Adithya Nair

* Table Of Contents :toc:
- [[#dsa-notes][DSA Notes]]
  - [[#graphs][Graphs]]
  - [[#trees][Trees]]
  - [[#heap][Heap]]
  - [[#tries][Tries]]

* DSA Notes
** Graphs
*** Representations Of A Graph
**** Adjacency Matrix

Adjacency matrices are matrices which can be used to represent the connections that nodes have to each other. This is done by making a matrix of size $n$ for $n$ nodes. And the following rules exist for generating the matrix.

1. If there is a link from node $i$ to node $j$ then the element $A_{ij}$ for the adjacency matrix $A$ is 1.
2. If there is no link, then the element is zero.

\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & &\ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn} \\
\end{bmatrix}

As a consequence of this, undirected graphs(graphs where the links represent connection rather than direction) are represented with a symmetric matrix.
**** Adjacency Lists
Adjacency lists are an alternative representation of graphs. If a graph has $n$ nodes, then the list has $n$ elements. The list adjList is then made with the following rules.

*adjList[i] contains all the nodes which are connected to vertex $i$, in the order in which they are connected.*

For an example graph,

\begin{align*}
&a \rightarrow b \rightarrow c \rightarrow d  \\
&\downarrow \\
&b \rightarrow a \rightarrow c \\
&\downarrow \\
&c \rightarrow a \rightarrow b \\
&\downarrow \\
&d \rightarrow a \rightarrow e\\
&\downarrow \\
&e \rightarrow d \\
\end{align*}

We have a linked list of linked lists. The problem here is that links are represented twice.

This is an optimization for when graphs have very few links.

*** Traversal(visit all nodes).
There are two algorithms of traversal:
1. Breadth-First Search - which involves the usage of queue
2. Depth-First Search - which involves the usage of stack

**** Breadth-First Search
Breadth-first involves selecting a root node, and choosing a neighbour node.

Revising queues, they have a First-In, First Out approach, insertion at the rear and deletion at the front.
The procedure follows:
- The queue starts by inserting any root node, say for example A.
- Now A is dequeued and stored in the result.
- Queue all neighbouring nodes of A.
- The first node is dequeued.
- Upon dequeueing, all neighbouring nodes are checked if it's in the queue. If not, they are queued in.
	- Let's say B is taken, and B is connected to C, and C is already connected to A and B.
	- A and C will not be queued.
- This iterates until there are no more nodes.

Clearly, this depends on the number of edges in the graph. The maximum number of edges in a graph is $^nC_2$.

The functions required in this queue are:
- `Insert()`
- `Delete()`
- `Traverse()`
#+begin_src java

#+end_src

#+RESULTS:

**** Depth-First Search
This involves traversing the nodes until an edge node is met, using a stack.

The procedure follows:
- A node is selected and pushed into the stack.
- A random node connected to A is pushed.
- A connected node is pushed.
- This procedure is met until no unvisited node exists
  - In which case the stack is full.
  - If the stack is still not full, it implies that there are nodes which haven't been visited.
- Now popping occurs
- The algorithm goes back and checks for unvisited nodes by popping the stack and checking the topmost element's adjacent nodes for unvisited nodes.
- This is done until the stack is empty

#+begin_src java
class DFS {
  DFS(int V)  {
    adj = new LinkedList[V];
    visited = new boolean[V];
    for (int i = 0; i < V; i++)
      adj[i] = new LinkedList<Integer>();
  }
}
#+end_src

#+RESULTS:

** Trees
A tree with at most two links from one node is known as a binary tree.
*** Properties
- Maximum number of nodes - $2^i$
- Height is longest distance between root to leaf nodes (count the edges)
- Maximum number of nodes possible till height h is $(2^0 + 2^1 + 2^2 + \cdots 2^h)$ = $2^{h+1} -1$
*** Types Of Binary Trees
**** Full/Proper/Strict Binary Tree
It is a tree where each node must contain 2 children except the leaf node.

- There are either two children or no children.
- The number of leaf nodes is equal to number of internal nodes + 1
- The minimum number of nodes is equal to $2^h + 1$
- Maximum number of nodes is the same as number of nodes in binary tree, $2^{h+1} - 1$
- The minimum height of the full binary tree is $log_2(n+1) - 1$
**** Complete Binary Tree
A binary tree where all the nodes are completely filled except the last level.

**** Degenerate Binary Tree
Exactly like a linked list.
**** Balanced Binary Tree
- The heights of left and right trees can have a maximum height difference of 1.
*** Binary Search Tree
Value of left node must be smaller than parent, and value of right node must be greater than the parent node.
**** Binary Search Tree Insertion
**** Binary Search Tree Deletion
- It works the same as a linked list operation.
- We use [[In order Traversal]] to figure out the node's value, it takes the value of its in order successor.
***** Binary Search Tree Traversal.
There are three types of traversal.
****** Pre-order Traversal.
- Process the root
- process left node subtree.
- process right node subtree.
- recursively repeat.
****** in order traversal
- process the left subtree
- process the root
- process the right subtree
- recursively repeat.
  **we use in order successors to figure out the value to copy.**
****** post order traversal
- process the left subtree
- process the right subtree
- process the root
- recursively repeat.
*** avl trees(height balanced binary tree)
what this solves is the fact that we have a series of insertions that are 'skinny'. an avl tree is balanced, the height is as minimal as possible.

Each node is given a balancing factor, $= h_l-h_r$
A tree is said to be imbalanced if any node is said to have a balancing factor $\geq$ 2.
there are 4 insertions that can be performed, also known as 'rotations':
- ll - /, ll rotation, involve shifting a node to the right, the central node in the line becomes a root node.
- rr - \, rr rotation, involves shifting a node to the left, the central node in the line becomes a root node.
- lr - <, lr rotation, the last node in the subtree becomes the root node(it forms an rr + ll rotation)
- rl - >, rl rotation, the last node in the subtree becomes the root node(perform an ll + rr rotation)

The first letter is the sub-tree, and the second letter is the child node.

Construct an AVL tree by inserting 14,17,11,7,53,4,13,12,8,16,19,60,20

All 4 rotations are capable of causing an imbalance.


** Heap
heap is a data structure with a complete binary tree. this tree is mainly used for creating an efficient sorting algorithm.
*** types of heap
there are two types of heap:
**** min heap
the value of the root node is less than or equal to  its children
**** max heap
the value of the root node is more than or equal to its children
*** definition
a heap is a special form of complete binary tree where the key value is lesser than or greater than its children.
a heap is typically represented as an array, the array representation for a tree, is for each node
a parent node is represented by $\frac{i}{2} - 1$, the left child node is $2\times i + 1$ and the right child node is $2 \times i + 2$

Heaps can be used for sorting, by deleting the root node until none are left, we get a sorted array.
*** Insertion
The process of insertion involves:
- Adding a node to the leftmost child node available.
- Comparing the node's value with the parent node
  - If current node's value is $i$, we have $\frac{(i-1)}{2}$
- If the comparison yields the result that the definition of heap does not hold, then the values of the parent node and the child node are swapped.
- Repeat until the comparison holds.

#+begin_src java
// i is the variable holding the last position
// k is the value we are trying to add to the heap.
void insert(A,i,k){
i = i + 1;
a[i] = k;
while(i > 0){
    if(a[(i-1)/2] > a[i]){
        t = a[i];
        a[i] = a[(i-1)/2];
        a[(i-1)/2] = t;
    }
    else
        return;
    }
  #+end_src
*** Deletion
- Deletion can only happen at the root node.
- This deletion takes place when you're trying to perform 'heap sort'.

For an array, [52,24,30,12,16,5]

We have 52 as the root node.

#+begin_src java
int k = a[0];
a[0] = a[n];
a[n] = k;
n = n-1;

#+end_src
*** Write a Java Program To Implement And Insert Elements Into A Heap The array = [80,100,30,20,70,15,19]

Write a program which can automatically arrange itself into a
** Tries
How do you go about storing a dictionary? We construct a root node with 26 child nodes, one for each letter. Then each letter, sequentially forms the subsequent child node.
