#+title: Advanced Data Structures And Algorithm Analysis
#+author: Adithya Nair

* Graphs
Graphs are nodes with links to each other. These links are defined by a matrix known as an **adjacency matrix**.

The best way to store such links is (under the assumption that the graphs in question are **bi-directional**) to store only the upper triangle of the adjacency matrix, while ignoring the diagonal.
** Storing Graph Data
#+begin_src java :session Graph
import java.util.*;
int c = 5;
int a[][] = new int[c][c];
int upperTriangleSize = (c*(c-1))/2;
int graph_data[] = new int[upperTriangleSize];
int k = 0;
for(int i = 0; i < c; i++){
	for(int j = i+1;j < c;j++){
		graph_data[k] =  a[i][j];
		k++;
	}
}
#+end_src

\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & &\ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn} \\
\end{bmatrix}

** Adjacency Lists
This consists of a one-dimensional array, specifically of pointers.
For an example graph,
\begin{align*}
&a \rightarrow b \rightarrow c \rightarrow d  \\
&\downarrow \\
&b \rightarrow a \rightarrow c \\
&\downarrow \\
&c \rightarrow a \rightarrow b \\
&\downarrow \\
&d \rightarrow a \rightarrow e\\
&\downarrow \\
&e \rightarrow d \\
\end{align*}

We have a linked list of linked lists. The problem here is that links are represented twice.

This is an optimization for when graphs have very few links.

** The method of traversal(visit all nodes).

There are two algorithms of traversal:
1. Breadth-First Search - which involves the usage of queue
2. Depth-First Search - which involves the usage of stack

*** Breadth-First Search
Breadth-first involves selecting a root node, and choosing a neighbour node.

Revising queues, they have a First-In, First Out approach, insertion at the rear and deletion at the front.
The procedure follows:
- The queue starts by inserting any root node, say for example A.
- Now A is dequeued and stored in the result.
- Queue all neighbouring nodes of A.
- The first node is dequeued.
- Upon dequeueing, all neighbouring nodes are checked if it's in the queue. If not, they are queued in.
	- Let's say B is taken, and B is connected to C, and C is already connected to A and B.
	- A and C will not be queued.
- This iterates until there are no more nodes.

Clearly, this depends on the number of edges in the graph. The maximum number of edges in a graph is $^nC_2$.

The functions required in this queue are:
- `Insert()`
- `Delete()`
- `Traverse()`

This will be covered in the next lab.
 NOTE - This will not work for nodes which are not connected to any node in the graph.

*** Depth-First Search

This involves traversing the nodes until an edge node is met, using a stack.

The procedure follows:
- A node is selected and pushed into the stack.
- A random node connected to A is pushed.
- A connected node is pushed.
- This procedure is met until no unvisited node exists
  - In which case the stack is full.
  - If the stack is still not full, it implies that there are nodes which haven't been visited.
- Now popping occurs
- The algorithm goes back and checks for unvisited nodes by popping the stack and checking the topmost element's adjacent nodes for unvisited nodes.
- This is done until the stack is empty

#+begin_src java
class DFS {
  DFS(int V)  {
    adj = new LinkedList[V];
    visited = new boolean[V];
    for (int i = 0; i < V; i++)
      adj[i] = new LinkedList<Integer>();
  }
}
#+end_src
* Trees
A tree with at most two links from one node is known as a binary tree.
** Properties
- Maximum number of nodes - $2^i$
- Height is longest distance between root to leaf nodes (count the edges)
- Maximum number of nodes possible till height h is $(2^0 + 2^1 + 2^2 + \cdots 2^h)$ = $2^{h+1} -1$
** Types Of Binary Trees
*** Full/Proper/Strict Binary Tree
It is a tree where each node must contain 2 children except the leaf node.

- There are either two children or no children.
- The number of leaf nodes is equal to number of internal nodes + 1
- The minimum number of nodes is equal to $2^h + 1$
- Maximum number of nodes is the same as number of nodes in binary tree, $2^{h+1} - 1$
- The minimum height of the full binary tree is $log_2(n+1) - 1$
*** Complete Binary Tree
A binary tree where all the nodes are completely filled except the last level.

*** Degenerate Binary Tree
Exactly like a linked list.
*** Balanced Binary Tree
- The heights of left and right trees can have a maximum height difference of 1.
** Binary Search Tree
Value of left node must be smaller than parent, and value of right node must be greater than the parent node.
*** Binary Search Tree Insertion
*** Binary Search Tree Deletion
- It works the same as a linked list operation.
- We use [[In order Traversal]] to figure out the node's value, it takes the value of its in order successor.
**** Binary Search Tree Traversal.
There are three types of traversal.
***** Pre-order Traversal.
- Process the root
- Process left node subtree.
- Process right node subtree.
- Recursively repeat.
***** In order Traversal
- Process the left subtree
- Process the root
- Process the right subtree
- Recursively repeat.
  **We use in order successors to figure out the value to copy.**
***** Post order Traversal
- Process the left subtree
- Process the right subtree
- Process the root
- Recursively repeat.
** AVL Trees(Height balanced binary tree)
What this solves is the fact that we have a series of insertions that are 'skinny'. An AVL tree is balanced, the height is as minimal as possible.

Each node is given a balancing factor, $= h_L-h_R$
A tree is said to be imbalanced if any node is said to have a balancing factor $\geq$ 2.
There are 4 insertions that can be performed, also known as 'rotations':
- LL - /, LL Rotation, involve shifting a node to the right, the central node in the line becomes a root node.
- RR - \, RR Rotation, involves shifting a node to the left, the central node in the line becomes a root node.
- LR - <, LR Rotation, the last node in the subtree becomes the root node(it forms an RR + LL Rotation)
- RL - >, RL Rotation, the last node in the subtree becomes the root node(perform an LL + RR Rotation)

The first letter is the sub-tree, and the second letter is the child node.

All 4 rotations are capable of causing an imbalance.
* Heap
Heap is a data structure with a complete binary tree. This tree is mainly used for creating an efficient sorting algorithm.
** Types Of Heap
There are two types of heap:
*** Min Heap
The value of the root node is less than or equal to  its children
*** Max Heap
The value of the root node is more than or equal to its children
** Definition
A heap is a special form of complete binary tree where the key value is lesser than or greater than its children.
A heap is typically represented as an array, the array representation for a tree, is for each node
A parent node is represented by $\frac{i}{2} - 1$, the left child node is $2*i + 1$ and the right child node is $2*i + 2$

Heaps can be used for sorting, by deleting the root node until none are left, we get a sorted array.
** Insertion
The process of insertion involves:
- Adding a node to the leftmost child node available.
- Comparing the node's value with the parent node
  - If current node's value is $i$, we have $\frac{(i-1)/2}$
- If the comparison yields the result that the definition of heap does not hold, then the values of the parent node and the child node are swapped.
- Repeat until the comparison holds.

#+begin_src java
// i is the variable holding the last position
// k is the value we are trying to add to the heap.
void insert(A,i,k){
i = i + 1;
a[i] = k;
while(i > 0){
    if(a[(i-1)/2] > a[i]){
        t = a[i];
        a[i] = a[(i-1)/2];
        a[(i-1)/2] = t;
    }
    else
        return;
    }
  #+end_src
** Deletion
- Deletion can only happen at the root node.
- This deletion takes place when you're trying to perform 'heap sort'.

For an array, [52,24,30,12,16,5]

We have 52 as the root node.

#+begin_src java
int k = a[0];
a[0] = a[n];
a[n] = k;
n = n-1;

#+end_src
** TODO Write a Java Program To Implement And Insert Elements Into A Heap The array = [80,100,30,20,70,15,19]

Write a program which can automatically arrange itself into a
