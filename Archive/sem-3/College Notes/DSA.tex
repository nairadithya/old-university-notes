% Created 2024-09-20 Fri 09:28
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Adithya Nair}
\date{\today}
\title{Advanced Data Structures And Algorithm Analysis}
\hypersetup{
 pdfauthor={Adithya Nair},
 pdftitle={Advanced Data Structures And Algorithm Analysis},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.4 (Org mode 9.7.11)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents

\section{DSA Notes}
\label{sec:orgc472923}
\subsection{Graphs}
\label{sec:orge817b3d}
\subsubsection{Representations Of A Graph}
\label{sec:org50452ed}
\begin{enumerate}
\item Adjacency Matrix
\label{sec:org433a36c}
Adjacency matrices are matrices which can be used to represent the connections that nodes have to each other. This is done by making a matrix of size \(n\) for \(n\) nodes. And the following rules exist for generating the matrix.

\begin{enumerate}
\item If there is a link from node \(i\) to node \(j\) then the element \(A_{ij}\) for the adjacency matrix \(A\) is 1.
\item If there is no link, then the element is zero.
\end{enumerate}

\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & &\ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn} \\
\end{bmatrix}

As a consequence of this, undirected graphs(graphs where the links represent connection rather than direction) are represented with a symmetric matrix.
\item Adjacency Lists
\label{sec:orgf01ca2f}
Adjacency lists are an alternative representation of graphs. If a graph has \(n\) nodes, then the list has \(n\) elements. The list adjList is then made with the following rules.

\textbf{adjlist[i] contains all the nodes which are connected to vertex \(i\), in the order in which they are connected.}

for an example graph,

\begin{align*}
&a \rightarrow b \rightarrow c \rightarrow d  \\
&\downarrow \\
&b \rightarrow a \rightarrow c \\
&\downarrow \\
&c \rightarrow a \rightarrow b \\
&\downarrow \\
&d \rightarrow a \rightarrow e\\
&\downarrow \\
&e \rightarrow d \\
\end{align*}

we have a linked list of linked lists. the problem here is that links are represented twice.

this is an optimization for when graphs have very few links.
\end{enumerate}
\subsubsection{traversal(visit all nodes).}
\label{sec:org0839c4a}
there are two algorithms of traversal:
\begin{enumerate}
\item breadth-first search - which involves the usage of queue
\item depth-first search - which involves the usage of stack
\end{enumerate}
\begin{enumerate}
\item breadth-first search
\label{sec:org8983821}
breadth-first involves selecting a root node, and choosing a neighbour node.

revising queues, they have a first-in, first out approach, insertion at the rear and deletion at the front.
the procedure follows:
\begin{itemize}
\item the queue starts by inserting any root node, say for example a.
\item now a is dequeued and stored in the result.
\item queue all neighbouring nodes of a.
\item the first node is dequeued.
\item upon dequeueing, all neighbouring nodes are checked if it's in the queue. if not, they are queued in.
\begin{itemize}
\item let's say b is taken, and b is connected to c, and c is already connected to a and b.
\item a and c will not be queued.
\end{itemize}
\item this iterates until there are no more nodes.
\end{itemize}

clearly, this depends on the number of edges in the graph. the maximum number of edges in a graph is \(^nc_2\).

the functions required in this queue are:
\begin{itemize}
\item `insert()`
\item `delete()`
\item `traverse()`
\end{itemize}
\item depth-first search
\label{sec:orgfcb65df}
this involves traversing the nodes until an edge node is met, using a stack.

the procedure follows:
\begin{itemize}
\item a node is selected and pushed into the stack.
\item a random node connected to a is pushed.
\item a connected node is pushed.
\item this procedure is met until no unvisited node exists
\begin{itemize}
\item in which case the stack is full.
\item if the stack is still not full, it implies that there are nodes which haven't been visited.
\end{itemize}
\item now popping occurs
\item the algorithm goes back and checks for unvisited nodes by popping the stack and checking the topmost element's adjacent nodes for unvisited nodes.
\item this is done until the stack is empty
\end{itemize}

\begin{verbatim}
class dfs {
  dfs(int v)  {
    adj = new linkedlist[v];
    visited = new boolean[v];
    for (int i = 0; i < v; i++)
      adj[i] = new linkedlist<integer>();
  }
}
\end{verbatim}
\end{enumerate}
\subsection{trees}
\label{sec:org850041e}

a tree with at most two links from one node is known as a binary tree.
\subsubsection{properties}
\label{sec:orgfdf15ff}
\begin{itemize}
\item maximum number of nodes - \(2^i\)
\item height is longest distance between root to leaf nodes (count the edges)
\item maximum number of nodes possible till height h is \((2^0 + 2^1 + 2^2 + \cdots 2^h)\) = \(2^{h+1} -1\)
\end{itemize}
\subsubsection{types of binary trees}
\label{sec:org42e8d41}
\begin{enumerate}
\item full/proper/strict binary tree
\label{sec:orgc7d3026}
it is a tree where each node must contain 2 children except the leaf node.

\begin{itemize}
\item there are either two children or no children.
\item the number of leaf nodes is equal to number of internal nodes + 1
\item the minimum number of nodes is equal to \(2^h + 1\)
\item maximum number of nodes is the same as number of nodes in binary tree, \(2^{h+1} - 1\)
\item the minimum height of the full binary tree is \(log_2(n+1) - 1\)
\end{itemize}
\item complete binary tree
\label{sec:org9f78063}
a binary tree where all the nodes are completely filled except the last level.
\item todo degenerate binary tree
\label{sec:org1d8b769}
exactly like a linked list.
\item balanced binary tree
\label{sec:org2f9db03}
\begin{itemize}
\item the heights of left and right trees can have a maximum height difference of 1.
\end{itemize}
\end{enumerate}
\subsubsection{binary search tree}
\label{sec:org460b678}
value of left node must be smaller than parent, and value of right node must be greater than the parent node.
\begin{enumerate}
\item binary search tree insertion
\label{sec:orga3d0543}
\item binary search tree deletion
\label{sec:orgbc1beb6}
\begin{itemize}
\item it works the same as a linked list operation.
\item we use in order traversal to figure out the node's value, it takes the value of its in order successor.
\end{itemize}
\end{enumerate}
\subsubsection{avl trees(height balanced binary tree)}
\label{sec:org374941f}
what this solves is the fact that we have a series of insertions that are 'skinny'. an avl tree is balanced, the height is as minimal as possible.

each node is given a balancing factor, \(= h_l-h_r\)
a tree is said to be imbalanced if any node is said to have a balancing factor \(\geq\) 2.
there are 4 insertions that can be performed, also known as 'rotations':
\begin{itemize}
\item ll - /, ll rotation, involve shifting a node to the right, the central node in the line becomes a root node.
\item rr - $\backslash$, rr rotation, involves shifting a node to the left, the central node in the line becomes a root node.
\item lr - <, lr rotation, the last node in the subtree becomes the root node(it forms an rr + ll rotation)
\item rl - >, rl rotation, the last node in the subtree becomes the root node(perform an ll + rr rotation)
\end{itemize}

the first letter is the sub-tree, and the second letter is the child node.

construct an avl tree by inserting 14,17,11,7,53,4,13,12,8,16,19,60,20

all 4 rotations are capable of causing an imbalance.
\subsection{heap}
\label{sec:org62f0645}
heap is a data structure with a complete binary tree. this tree is mainly used for creating an efficient sorting algorithm.
\subsubsection{Types Of Heap}
\label{sec:org940d6ad}
there are two types of heap:
\begin{enumerate}
\item Min Heap
\label{sec:org0fae3cc}
the value of the root node is less than or equal to its children
\item Max Heap
\label{sec:orgcd759c4}
the value of the root node is more than or equal to its children
\end{enumerate}
\subsubsection{Definition}
\label{sec:org65c9edd}
a heap is a special form of complete binary tree where the key value is lesser than or greater than its children.
a heap is typically represented as an array, the array representation for a tree, is for each node
a parent node is represented by \(\frac{i}{2} - 1\), the left child node is \(2\times i + 1\) and the right child node is \(2 \times i + 2\)

heaps can be used for sorting, by deleting the root node until none are left, we get a sorted array.
\subsubsection{Insertion}
\label{sec:org89840a4}
the process of insertion involves:
\begin{itemize}
\item adding a node to the leftmost child node available.
\item comparing the node's value with the parent node
\begin{itemize}
\item if current node's value is \(i\), we have \(\frac{(i-1)}{2}\)
\end{itemize}
\item if the comparison yields the result that the definition of heap does not hold, then the values of the parent node and the child node are swapped.
\item repeat until the comparison holds.
\end{itemize}

\begin{verbatim}
// i is the variable holding the last position
// k is the value we are trying to add to the heap.
void insert(a,i,k){
i = i + 1;
a[i] = k;
while(i > 0){
    if(a[(i-1)/2] > a[i]){
        t = a[i];
        a[i] = a[(i-1)/2];
        a[(i-1)/2] = t;
    }
    else
        return;
    }
\end{verbatim}
\subsubsection{Deletion}
\label{sec:orga785a8f}
\begin{itemize}
\item Deletion can only happen at the root node.
\item This deletion takes place when you're trying to perform 'heap sort'.
\end{itemize}

For an array, [52,24,30,12,16,5]

We have 52 as the root node.

\begin{verbatim}
int k = a[0];
a[0] = a[n];
a[n] = k;
n = n-1;
\end{verbatim}
\subsection{Tries}
\label{sec:org56c4899}
How do you go about storing a dictionary? We construct a root node with 26 child nodes, one for each letter. Then each letter, sequentially forms the subsequent child node.

Trie is a sorted tree based data structure that stores a set of strings, it has \(n\) pointers, where \(n\) is the number of characters in the alphabet, in each node. It can search a word in the dictionary with the help of the character nodes preceding the end of the word. It searches incrementally by character.
\subsubsection{Properties Of Trie}
\label{sec:org97fff9c}
\begin{itemize}
\item the root node of the trie is empty with \(n\) pointers, it represents the 'full' node
\item each child node is sorted alphabetically.
\item each node can have a maximum of \(n\) children.
\end{itemize}
\subsubsection{Applications}
\label{sec:org118f415}
\begin{itemize}
\item Dictionary
\item Address Book
\item Phone Book
\item Spell checker
\item Browser history
\end{itemize}
\subsection{Hashing}
\label{sec:orgcd9ef53}
\subsubsection{Hash Table}
\label{sec:orga49b155}
Hash tables are a 2-dimensional data structure of a fixed size. They allow you to have one probe, the data can be returned immediately
\subsubsection{Hash Functions}
\label{sec:orgfaf7567}
\begin{enumerate}
\item Division method
Given a set of data \(k\), for a one-dimensional hash table of a size \(n\), We store the elements, where \(u\) is the element in the hash and the hash function is \(h(k)\)
\(i = h_{k} \% n\)  \(u_i = k\), we find the index through the modulus function and store it in the corresponding element within the array.
\end{enumerate}

QUESTION: Use division method, to store the following data into a hash table of size \(m=10\), the has function is \(h_k = (2k_i + 5)\)

\begin{enumerate}
\item Folding method
\item Mid-square method
\item Modulo-multiplication method
\end{enumerate}
\subsubsection{Collision Avoidance Methods}
\label{sec:org5bf62ad}
For open hashing, chaining method is used for collision handling
The chaining method involves creating a pointer to another node, and the conflict element is added to that node instead.

For closed hashing,
Three methods to handle collision:
\begin{enumerate}
\item Linear probing
When a collision occurs, insert the hash into the subsequent node \((u+i)\%n)\).
\item Quadratic probing
When a collision occurs, insert the hash into the node \((u+i^2)\%10)\)
\item Double hashing
We use two hashing functions

\begin{itemize}
\item \(h_1(k) = u\)
\item \(h_2(k) = v\)
\end{itemize}
\end{enumerate}

When there is a collision, the second hashing function is used, in every other case the first hashing function is used.

Then the new index is calculated,

$$w = (u+v*i)\%m$$

Let's take an example, we define \(h_1(k) = (2k+1)\%10\), \(h_2(k) = (3k+2)\%10\)

\begin{center}
\begin{tabular}{rrllr}
\hline
Key & U & V & W & Probe\\
\hline
6 & 3 & - & - & 1\\
12 & 5 & - & - & 1\\
18 & 7 & - & - & 1\\
10 & 1 & - & - & 1\\
2 & 5 & - & 9 & 4\\
18 & - & - & - & -\\
22 & - & - & - & -\\
\hline
\end{tabular}
\end{center}


Now we write the hash table,
\begin{center}
\begin{tabular}{rl}
\hline
\textbf{index} & \textbf{key}\\
\hline
0 & -\\
1 & 10\\
2 & -\\
3 & 6\\
4 & -\\
5 & 12\\
6 & -\\
7 & 8\\
8 & -\\
9 & 2\\
\hline
\end{tabular}
\end{center}
The data array A is equal to 3,2,9,6,11,13,7,12, \(n = 10\), \(h_k = 2k + 3\), \(h2(k) = 3k + 1\), plot the order of storage  of the data in a hash table and total probing, and average probing, with respect to chaining, linear probing, quadratic probing, double hashing
\begin{center}
\begin{tabular}{rrrll}
\hline
Key & U & V & W & Probe\\
\hline
3 & 9 & 0 &  & \\
2 & 7 & 7 &  & \\
6 & 5 & 9 &  & \\
9 & 1 & 8 &  & \\
11 & 5 & 4 &  & \\
13 & 9 & 0 &  & \\
7 & 7 & 2 &  & \\
12 & 7 & 7 &  & \\
\end{tabular}
\end{center}
\subsection{Merkel Trees}
\label{sec:org64c4d7a}
A hash tree is a data structure used for data verification and synchronization. It is a tree where each non-leaf node is a hash of its child node.
\begin{itemize}
\item The first layer is the list of all transacttion IDs in a block
\item The data itself is not part the merkel tree, the first hashed values are the child nodes.
\item These IDs are concatenated and hashed using SHA-256
\item The second layer will be half the length of the first layer
\end{itemize}
\subsubsection{Usage}
\label{sec:org2e91e54}
The hash nodes are used to check if data is corrupted. If the root node of the hashing function differs from the merkel tree generated from the data, then we have an issue.
\end{document}
